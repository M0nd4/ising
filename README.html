<h1>ISING - An Ising model simulator</h1>

<h2>Building the source code</h2>

<p>Simply run:</p>

<pre><code> ./configure
 make
 make install
</code></pre>

<p>After <code>make install</code>, the <strong>ising</strong> program will be found in 
the <code>install/bin</code> directory. If you want to install the ising model simulator
in a global directory you can use the <code>--prefix</code> option:</p>

<pre><code> ./configure --prefix=/usr/local
 make
 sudo make install
</code></pre>

<h2>Using the Ising model simulator:</h2>

<h3>Introduction</h3>

<p>To be written. If you are here you should know a bit about the Ising model
and the Metropolis algorithm.</p>

<h4>Program workflow</h4>

<p>This is more or less how the program works:</p>

<ol>
<li>Parse input parameters.</li>
<li>Initialize geometry.</li>
<li>Initialize spins values (+1,-1).</li>
<li>Compute Energy and Magnetization.</li>
<li>Perform <code>--ieq</code> Metropolis sweeps to thermalize the state of the system.</li>
<li>Perform <code>--nmcs</code> sweeps, printing the Energy, the Magnetization and an 
estimation of the cluster radius every <code>--nmeas</code> measures.</li>
</ol>

<h3>Geometry</h3>

<p>The ising model simulator defines an hypercubic lattice, which allows
the following parameters to be set:</p>

<ul>
<li>Dimension (-d):
<ul>
<li>2: Square lattice</li>
<li>3: Cubic lattice</li>
<li>4: Hypercubic lattice</li>
<li>5: 5-dimesion cube</li>
<li>...</li>
</ul></li>
<li><p>Side length (-L): The number of spins of each dimension.</p></li>
<li><p>Print state (--print-state): This option, only enabled if dimension is 2,
 will create a "state" subdirectory with several text files that contain
 a  LxL square matrix with the position of the spins (either UP or DOWN). This 
 text file can be used later on to plot an image of the system and seeing
 the formed clusters.</p></li>
</ul>

<p>Examples:</p>

<ul>
<li>On a "-d 2 -L 20" lattice, we will have 20^2 = 400 spins</li>
<li>On a "-d 3 -L 8" lattice, we will have 8^3 = 512 spins</li>
</ul>

<h4>Using non hypercubic geometries:</h4>

<p>The Ising model simulator may be used with any given geometry. However, an
initialization routine for any other specific geometry has to be implemented.</p>

<p>If you want to use a different geometry, only the <code>main</code> function would need
to be changed, preferably by replacing the <code>InitHypercubicLattice</code> function
or adding another switch option to the program (i.e. <code>--geometry</code>).</p>

<p>Patches are welcome.</p>

<p>Generic initialization routines for reading geometries from files would also
be very welcome.</p>

<h3>Metropolis parameters</h3>

<p>We consider a "MonteCarlo sample" a loop over all sites of the system 
(this is "full sweep of the lattice"). This means that a single sample 
on a lattice of 400 spins, consists of 400 update proposals.</p>

<p>Using this convention, it is easier to compare Metropolis convergence
on different system sizes. Bear in mind that the larger the system is,
the longer will take a single "MonteCarlo sample" as more updates will 
be necessary to do a single sweep.</p>

<p>The Metropolis algorithm allows the following parameters:</p>

<ul>
<li>Thermalization iterations (--ieq): Just after the system initialization,
  it may be convenient to discard a number of samples in order to allow 
  the system to reach an equilibrium state. Set this parameter to 0 if 
  you want to see the thermalization.</li>
<li>Number of MonteCarlo samples (--nmcs): The total number of MonteCarlo 
  samples to perform after thermalization.</li>
<li>Number of samples between each measurement (--nmeas): The number of 
  samples to perform between each system printing. For instance, if 
  we want to do 100000 sweeps, but only print 1000 values of the energy
  and magnetization, we would use an <code>--nmeas 100</code>.</li>
</ul>

<h3>Dynamics</h3>

<p>The Metropolis algorithm does not impose a particular dynamic of the system. 
A dynamic describes "how the updates should be performed". The available
dynamics are:</p>

<ul>
<li>Glauber: A spin is chosen randomly and flipped.</li>
<li>Glauber sequential: Spins are flipped sequentially, following on every 
   sweep the same order.</li>
<li>Kawasaki random: Two opposite spins are chosen randomly and and exchanged.</li>
<li>Kawasaki neighbours: Two opposite neighbouring spins are chosen randomly
   and exchanged. TODO: The implementation of this dynamic is biased for 
   geometries where some spins have more neighbours than others (not the
   hypercubic case).</li>
<li>Wolff: This is a clustering dynamic.
<ol>
<li>A spin S1 is chosen randomly.</li>
<li>Check the spin of each of the S1 neighbours. If the neighbour's spin is 
the opposite of S1, then that neighbour is not added to the cluster but
if spins are the same, then the neighbour is added to the cluster with
an acceptance rate which depends on the temperature.</li>
<li>Move to the added neighbours and repeat until a cluster is formed.</li>
<li>Flip the cluster.</li>
</ol></li>
</ul>
